# ralph-starter

A ready-to-use scaffold for the Ralph Wiggum autonomous AI development loop.

```
 .-"""-.
/        \
|  O    O  |
|    __    |
|   /  \   |
 \  '=='  /
  '-.  .-'     "I'm helping!"
```

## What is this?

The Ralph Wiggum technique is an autonomous AI coding loop where Claude (or another LLM) iteratively implements features from specs — one task per iteration, fresh context each time. You write the specs, Ralph does the work.

This repo gives you the battle-tested file structure and prompts to get started immediately.

## Quick Start

### 1. Clone and set up

```bash
git clone <this-repo> my-project
cd my-project
rm -rf .git && git init
```

**Or open in a devcontainer** — see [Devcontainer](#devcontainer) below for an isolated, pre-configured environment.

### 2. Customize AGENTS.md

Edit `AGENTS.md` with your project's:
- Build and test commands
- Project layout
- Any conventions Ralph should follow

### 3. Write your first spec

```bash
# Delete the example
rm specs/example-spec.md

# Write your own
cat > specs/my-feature.md << 'EOF'
---
title: My Feature
status: ready
priority: high
tags: [core]
---

# My Feature

## Problem
What problem does this solve?

## Requirements
- What it must do
- How to verify it works
EOF
```

Update `specs/todo.md` to track it:
```markdown
- [ ] My Feature (`specs/my-feature.md`)
```

### 4. Run the planning loop

```bash
chmod +x loop.sh
./loop.sh plan
```

This generates `IMPLEMENTATION_PLAN.md` with a prioritized task breakdown.

### 5. Run the build loop

```bash
./loop.sh        # Unlimited iterations
./loop.sh 5      # Max 5 iterations
```

Ralph picks the highest-priority task, implements it, runs tests, commits, and exits. The loop restarts with fresh context and picks the next task.

**Ctrl+C** to stop at any time.

## File Structure

```
my-project/
├── loop.sh                         # The loop script
├── PROMPT_build.md                 # Build mode instructions (implement)
├── PROMPT_plan.md                  # Plan mode instructions (gap analysis)
├── AGENTS.md                       # Operational guide (how to build/test)
├── IMPLEMENTATION_PLAN.md          # Task list (generated by planning loop)
├── IMPLEMENTATION_PLAN_ARCHIVE.md  # Completed tasks (survives plan regen)
├── specs/                          # Requirement specs (immutable)
│   ├── todo.md                     # Feature tracker (only specs/ file agents update)
│   ├── my-feature.md               # Your specs go here
│   └── archive/                    # Completed specs moved here
└── src/                            # Your source code
```

## How It Works

### Three Phases

1. **Define Requirements** — You write specs in `specs/`. One file per topic. Be specific about what, not how.
2. **Plan** (`./loop.sh plan`) — Claude analyzes specs vs code, produces a prioritized task list in `IMPLEMENTATION_PLAN.md`.
3. **Build** (`./loop.sh`) — Claude picks a task, implements it, runs tests, commits. Loop restarts fresh.

### Two Prompts

| File | When | What it does |
|------|------|-------------|
| `PROMPT_plan.md` | `./loop.sh plan` | Gap analysis, task breakdown. No code changes. |
| `PROMPT_build.md` | `./loop.sh` | Implement one task, test, commit. |

### Key Principles

- **One task per iteration** — keeps context focused and diffs reviewable
- **Fresh context every loop** — no accumulated confusion
- **Backpressure via tests** — Ralph can't commit if tests fail
- **AGENTS.md is operational memory** — how to build/test, not a changelog
- **Specs are immutable** — you write them, Ralph reads them
- **Plan is disposable** — regenerate with `./loop.sh plan` when stale

### Archive Convention

When a JTBD is fully complete:
- **Specs**: Move from `specs/` to `specs/archive/`, set `status: done`
- **Plan sections**: Move from `IMPLEMENTATION_PLAN.md` to `IMPLEMENTATION_PLAN_ARCHIVE.md`, add `archive` to tags

This prevents done work from being lost when the plan is regenerated.

## Writing Good Specs

A spec should answer:
- **What problem** does this solve? (Problem section)
- **What must it do?** (Requirements — observable, testable)
- **What could go wrong?** (Edge cases)

Keep specs focused: one topic per file. If you need "and" to describe it, split it.

```markdown
---
title: User Authentication
status: ready
priority: high
tags: [auth, security]
---

# User Authentication

## Problem
Users need to log in securely.

## Requirements
- Support email/password login
- Hash passwords with bcrypt
- Issue JWT tokens with 24h expiry
- Return 401 for invalid credentials

## Edge Cases
- Empty email or password
- Email not found
- Correct email, wrong password
- Expired token refresh
```

## Tips

- **Watch the first few iterations** — observe where Ralph goes wrong, add guardrails to prompts
- **Add utilities to your codebase** — Ralph discovers patterns and follows them
- **Run in a sandbox** — `--dangerously-skip-permissions` means no safety net
- **Regenerate the plan** when Ralph goes in circles: `./loop.sh plan`
- **Keep AGENTS.md under 60 lines** — it loads every iteration
- **Use [spec-view](https://pypi.org/project/spec-view/)** (`pip install spec-view`) — a TUI + web dashboard that gives you a live view of your specs, tasks, and progress. It parses `IMPLEMENTATION_PLAN.md` sections, tracks task completion, and auto-detects the archive convention. Run `spec-view` for the terminal dashboard or `spec-view serve` for the web UI.

## Devcontainer

The repo includes a devcontainer config so you can run the loop in an isolated environment — recommended since `loop.sh` uses `--dangerously-skip-permissions`.

### VS Code / Cursor

1. Install the **Dev Containers** extension
2. Set your API key as an environment variable on your host:
   ```bash
   export ANTHROPIC_API_KEY=sk-ant-...
   ```
3. Open the repo and choose **"Reopen in Container"** from the command palette
4. The container installs Claude CLI automatically — start the loop:
   ```bash
   ./loop.sh plan
   ```

### GitHub Codespaces

1. Add `ANTHROPIC_API_KEY` to your [Codespaces secrets](https://github.com/settings/codespaces)
2. Create a codespace from this repo
3. Claude CLI is installed on creation — run `./loop.sh`

### Customizing the container

The devcontainer uses the Ubuntu base image with Node.js (required for Claude CLI). To add your project's runtime, edit `.devcontainer/devcontainer.json` and add features:

```jsonc
"features": {
  "ghcr.io/devcontainers/features/node:1": {},
  "ghcr.io/devcontainers/features/python:1": {},   // Python
  "ghcr.io/devcontainers/features/rust:1": {},      // Rust
  "ghcr.io/devcontainers/features/go:1": {}          // Go
}
```

See [available features](https://containers.dev/features) for more options.

## Safety

The loop runs with `--dangerously-skip-permissions`. This means Claude can execute any command without asking. Run in an isolated environment:

- Devcontainer (included — see above)
- Docker container or VM
- Only the API keys needed for the task
- No access to private data beyond the project
- Restrict network if possible

## Credits

Based on the [Ralph Wiggum technique](https://ghuntley.com/ralph/) by Geoffrey Huntley. Playbook distilled from the [ralph-playbook](https://github.com/ClaytonFarr/ralph-playbook) by Clayton Farr.
